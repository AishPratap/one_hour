package chap4_tree_graph;

import java.util.*;
/**
 *
 * @author hkhoi
 */
public class ToDo {
    
    /**
     * Check if a tree is balanced
     * @param root
     * @return 
     */
    public boolean isBalanced(Node root) {
        
        return false;
    }
    
    /**
     * Check if there is a route between two nodes
     * @param from
     * @param to
     * @return 
     */
    public boolean isThereARoute(Node from, Node to) {
        
        return false;
    }
    
    /**
     * Given an array of integers. Build a binary search tree with minimum length
     * @param array
     * @return 
     */
    public Node buildBinTree(int[] array) {
        
        return null;
    }
    
    /**
     * Given a binary tree of depth D, return D linked lists of each depth
     * @param root
     * @return 
     */
    public ArrayList<LinkedList<Integer>> getLayers(Node root) {
        
        return null;
    }
    
    /**
     * Given a binary tree, check if it is a binary search tree or not
     * @param node
     * @return 
     */
    public boolean isBinSearchTree(Node node) {
        
        return false;
    }
    
    /**
     * Return the next in-order successor. Parent can be called.
     * @param node
     * @return 
     */
    public Node next(Node node) {
        
        return null;
    }
    
    /**
     * Given a binary search tree. Find the first common ancestor between two nodes.
     * @param node0
     * @param node1
     * @return 
     */
    public Node commonAncestorBinSearch(Node node0, Node node1) {
        
        return null;
    }
    
    /**
     * Same as above, but it is not strictly a binary search tree
     * @param node0
     * @param node1
     * @return 
     */
    public Node commonAncestorBin(Node node0, Node node1) {
        
        return null;
    }
    
    /**
     * Check if a tree is a subtree of another tree
     * @param bigTree
     * @param smallTree
     * @return 
     */
    public boolean isSubTree(Node bigTree, Node smallTree) {
        return false;
    }
    
    /**
     * Display all path that sum up to value
     * @param root
     * @param value 
     */
    public void allPath(Node root, int value) {
        
    }
}
